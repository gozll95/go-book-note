f, err := os.Open(filename) if err != nil {
        log.Println("Open file failed:", err)
return }
defer f.Close()
... // 操作已经打开的f文件
这里有两个关键点。其一是defer关键字。defer语句的含义是不管程序是否出现异常,均 在函数退出时自动执行相关代码。在上面的例子中,正是因为有了defer,才使得无论后续是否 会出现异常,都可以确保文件被正确关闭。其二是Go语言的函数允许返回多个值。大多数函数 的最后一个返回值会为error类型,以在错误情况下返回详细信息。error类型只是一个系统内 置的interface,如下:
type error interface { Error() string
}


##并发
Go语言引入了goroutine概念,它使得并发编程变得非常简单。通过使用goroutine而不是裸用 操作系统的并发机制,以及使用消息传递来共享内存而不是使用共享内存来通信,Go语言让并 发编程变得更加轻盈和安全。


通过在函数调用前使用关键字go,我们即可让该函数以goroutine方式执行。goroutine是一种 比线程更加轻盈、更省资源的协程。Go语言通过系统的线程来多路派遣这些函数的执行,使得 每个用go关键字执行的函数可以运行成为一个单位协程。当一个协程阻塞的时候,调度器就会自 动把其他协程安排到另外的线程中去执行,从而实现了程序无等待并行化运行。而且调度的开销 非常小,一颗CPU调度的规模不下于每秒百万次,这使得我们能够创建大量的goroutine,从而可 以很轻松地编写高并发程序,达到我们想要的目的。


Go语言实现了CSP(通信顺序进程,Communicating Sequential Process)模型来作为goroutine 间的推荐通信方式。在CSP模型中,一个并发系统由若干并行运行的顺序进程组成,每个进程不 能对其他进程的变量赋值。进程之间只能通过一对通信原语实现协作。Go语言用channel(通道) 这个概念来轻巧地实现了CSP模型。channel的使用方式比较接近Unix系统中的管道(pipe)概念, 可以方便地进行跨goroutine的通信。



#####################################################################
用法:
    $ calc help
    USAGE: calc command [arguments] ...
    The commands are:
    sqrt       Square root of a non-negative value.
    add        Addition of two values.
$ calc sqrt 4 # 开根号 2
$calcadd12# 加法 3
我们假设这个工程被分割为两个部分:
 可执行程序,名为calc,内部只包含一个calc.go文件;
 算法库,名为simplemath,每个command对应于一个同名的go文件,比如add.go。
则一个正常的工程目录组织应该如下所示:
<calcproj> ├─<src>
├─<calc> ├─calc.go
├─<simplemath> ├─add.go
├─add_test.go ├─sqrt.go ├─sqrt_test.go
├─<bin> ├─<pkg>#包将被安装到此处
在上面的结构里,带尖括号的名字表示其为目录。xxx_test.go表示的是一个对于xxx.go的单元 测试,这也是Go工程里的命名规则。



########################################################################

mySlice2 := []int{8, 9, 10}
// 给mySlice后面添加另一个数组切片
mySlice = append(mySlice, mySlice2...)

########################################################################

value, ok := myMap["1234"] ifok{// 找到了
// 处理找到的value }

########################################################################


1. 不定参数类型
不定参数是指函数传入的参数个数为不定数量。为了做到这点,首先需要将函数定义为接受 不定参数类型:
  func myfunc(args ...int) {
for _, arg := range args {
        fmt.Println(arg)
    }
} 这段代码的意思是,函数myfunc()接受不定数量的参数,这些参数的类型全部是int,所
以它可以用如下方式调用:
    myfunc(2, 3, 4)
    myfunc(1, 3, 7, 13)
 形如...type格式的类型只能作为函数的参数类型存在,并且必须是最后一个参数。它是一 个语法糖(syntactic sugar),即这种语法对语言的功能并没有影响,但是更方便程序员使用。通 常来说,使用语法糖能够增加程序的可读性,从而减少程序出错的机会。
从内部实现机理上来说,类型...type本质上是一个数组切片,也就是[]type,这也是为 什么上面的参数args可以用for循环来获得每个传入的参数。
  func myfunc2(args []int) {
for _, arg := range args {
        fmt.Println(arg)
    }
}
8
9
 从函数的实现角度来看,这没有任何影响,该怎么写就怎么写。但从调用方来说,情形则完 全不同:
myfunc2([]int{1, 3, 7, 13})


########################################################################


即使其中的Copy()函数抛出异常,Go仍然会保证dstFile和srcFile会被正常关闭。 如果觉得一句话干不完清理的工作,也可以使用在defer后加一个匿名函数的做法:
defer func() {
// 做你复杂的清理工作
} () 另外,一个函数中可以存在多个defer语句,因此需要注意的是,defer语句的调用是遵照
  先进后出的原则,即最后一个defer语句将最先被执行。只不过,当你需要为defer语句到底哪 个先执行这种细节而烦恼的时候,说明你的代码架构可能需要调整一下了。

#################################################
当在一个函数执行过程中调用panic()函数时,正常的函数执行流程将立即终止,但函数中 之前使用defer关键字延迟执行的语句将正常展开执行,之后该函数将返回到调用函数,并导致 逐层向上执行panic流程,直至所属的goroutine中所有正在执行的函数被终止。错误信息将被报 告,包括在调用panic()函数时传入的参数,这个过程称为错误处理流程。
从panic()的参数类型interface{}我们可以得知,该函数接收任意类型的数据,比如整 型、字符串、对象等。调用方法很简单,下面为几个例子:
panic(404)
panic("network broken") panic(Error("file not exists"))
recover()函数用于终止错误处理流程。一般情况下,recover()应该在一个使用defer 关键字的函数中执行以有效截取错误处理流程。如果没有在发生异常的goroutine中明确调用恢复 过程(使用recover关键字),会导致该goroutine所属的进程打印异常信息后直接退出。
以下为一个常见的场景。
我们对于foo()函数的执行要么心里没底感觉可能会触发错误处理,或者自己在其中明确加 入了按特定条件触发错误处理的语句,那么可以用如下方式在调用代码中截取recover():
defer func() {
if r := recover(); r != nil {
            log.Printf("Runtime error caught: %v", r)
        }
}()
foo() 无论foo()中是否触发了错误处理流程,该匿名defer函数都将在函数退出时得到执行。假
如foo()中触发了错误处理流程,recover()函数执行将使得该错误处理过程终止。如果错误处 理流程被触发时,程序传给panic函数的参数不为nil,则该函数还会打印详细的错误信息。

##################################################################################################################




